-- Разобраться как построен и работает следующий запрос:
-- Правильно-ли он построен?
-- Какие изменения, включая денормализацию, можно внести в структуру БД
-- чтобы существенно повысить скорость работы этого запроса?

SELECT 	
		CONCAT(u.firstname, ' ', u.lastname) as user, 
		count(l.id) as count, 
		TIMESTAMPDIFF(YEAR, p.birthday, NOW()) AS age
			FROM users AS u
		INNER JOIN profiles AS p
			ON p.user_id = u.id
		LEFT JOIN media as m
			ON m.user_id = u.id
		LEFT JOIN messages as t
			ON t.from_user_id = u.id
		LEFT JOIN
			likes AS l
				ON l.item_id = u.id AND l.like_type_id = 2 -- лайки для самих пользователей
				OR l.item_id = m.id AND l.like_type_id = 1 -- лайки для их медиа
				OR l.item_id = t.id AND l.like_type_id = 3 -- лайки для их сообщений
		GROUP BY u.id
		ORDER BY p.birthday DESC
	LIMIT 10;

-- Как он работает: производится выборка из 5 таблиц,  (здесь мы избегаем запроса в таблицу like_types ещё)
-- которые объединяются: юзеры с профилями по признаку взаимного вхождения,
-- А далее медиа и сообщения по типу "все полученные ранее пользователи-профили"
-- с соотв. медиа и с соотв. сообщениями левым джойном
-- Ну и в конце все полученные "пользователи-их_медиа-сообщения" объединяюися с лайками
-- Также по принципу левого джоина

-- Правильно ли он построен? Не знаю ) наверное да - работает вроде бы ))

-- Как повысить скорость работы этого запроса: 
-- Ну во-первых индексы на профиль-день-рождения, поскольку по нему будет сортировка
-- Индекс медиа-юзер_id был бы полезен
-- Индекс сообщение-from_user_id тоже поможет видимо..
-- С лайками ситуация сложнее.. индекс item_id, like_type_id был бы полезен..

-- В целом мне думается, что один из вариантов связанных с денормализацией мог бы быть:
-- создание таблицы лайков с разреженными полями для like_item_id.. То-есть media_like_id, message_like_id, user_like_id
-- В таком варианте можно было бы сделать уникальные индексы (юзер может только они раз лайкнуть одну сущность)
-- Но с другой стороны индексов станет больше. Возможно это негативно скажется в плане производительности сервера... 
-- Тут сне судить сложно пока.

-- Разобрать лайки на разные таблицы.. врядли - объединений в джоине станет еще больше - это не хорошо неверное.
-- К тому-же их будет потенциально все больше и больше - если будут добавляться возможности лайков новых сущностей..

-- Другой вариант - предварительный подсчет лайков и хранение этого значения прямо в юзерах. Это, как говорилось 
-- на вебинаре самый эффективный в плане последующих запросов вариант, но реализовывать его придется с помощью 
-- Внешних процедур, и в случае лайков - скорее всего с применением триггеров, поскольку актуальность этой информации
-- Должна быть стопроцентная. В своем прокте подобные поля я вычисляю периодическими рассчетами (планировщик запускает 
-- раз в минуту/час/день соответствующие процедуры) но у меня они касаются подсчетов рейтингов и тп, что не является
-- так уж строго актуальным в реальном времени...

-- В общем, пока мысли вокруг таких вариантов вьются.. опыта крайне мало, поэтому не особо думается даже ))